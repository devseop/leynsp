# D3를 이용해 데이터 시각화하기

현재 저는 마케팅 데이터를 AI를 이용한 분석을 제공해주는 솔루션 스타트업에서 프론트엔드 개발자로 일하고 있습니다. 기존에 [질문하기]와 [데이터 업로드]로 구성되어 있던 서비스가 온전히 데이터를 취합하여 대시보드로 보여지게 되면서 백엔드를 통해 받은 데이터를 보기 쉽게 그래프로 표현해줘야 했는데요. 취업 전에는 주로 `Chart.js`를 이용해 빠르게 시각화를 진행했지만, 이번에는 서비스가 전체적으로 개편이 되고 차트 라이브러리를 사용하면서 커스텀이 잘 되지 않았던 기억이 있어 `D3.js`를 이용하여 데이터 시각화를 진행했습니다.

## D3.js 알아보기
먼저 D3는 Data-Driven-Development의 약자로 D가 3번 반복되서 D3라고 부르며, 웹에서 동적이고 인터렉티브한 데이터 시각화를 구현하기 위한 자바스크립트 라이브러리입니다. 여러 장점이 있지만 

## 개발하기

1. 화면에서 옵션(문단 길이와 개수, 소스)을 선택하면 옵션에 따른 한글 로렘 입숨이 노출됩니다.
2. 선택한 소스는 긴 문자열 형태로 되어있으며, 공백을 기준으로 나뉘고 재조합됩니다.

### 1. 타입 구조

TypeScript를 활용하여 프로젝트의 쓰일 type 구조를 미리 정의합니다.

```ts
// 생성된 한글 로렘 입숨
export type ParagraphProps = string[];

// 한글 로렘 입숨 생성을 위한 폼양식
export type FormStateProps = {
  paragraphNumber: number;
  paragraphLength: string;
  paragraphSource: string;
  generatedParagraphs: ParagraphProps;
};

// 한글 로렘 입숨에 쓰일 시 객체
export type PoemProps = {
  author: string;
  poem: string;
};

// 시 객체의 모음
export type PoemListProps = PoemProps[];
```

`PoemProps`는 `author`와 `poem`을 가지고 있는데 이는 기획 초기 단계에 시인의 이름을 활용할 수 있는 방법을 생각했던 흔적입니다. 기획 초기에는 한글 로렘 입숨을 생성하는 것뿐만 아니라 mock data를 만드는 것까지 발전하였으나, 작은 단계부터 실행하여 최소의 결과물을 도출한 후 살을 덧붙여 나가는 것이 나은 판단이라고 생각되어 폐기하였습니다.

### 2. 문자열 재조합

선택된 소스의 문자열을 공백(' ')을 기준으로 하여 모두 나눈 후, `Math.floor`와 `Math.random`을 이용하여 분리된 문자열을 선택하기 위한 `randomIndex`를 만들고 이를 이용해 선택된 단어를 `paragraph`에 추가합니다. 이 과정은 `paragraph`의 길이가 `maxLength`보다 커지기 전까지 반복되며, 동작이 끝나면 `trim()`으로 문자열 끝의 공백을 없앤 `paragraph`를 `randomParagraphs`에 넣어 반환하도록 합니다.

```ts
export const getRandomParagraphs = (
  formData: FormStateProps,
): ParagraphProps => {
  const {
    paragraphSource: source,
    paragraphNumber: count,
    paragraphLength: length,
  } = formData;

  const selectedPoem = poems.find((peom) => peom.subject === source);

  if (!selectedPoem) return [];

  const lines = selectedPoem.poem.split(' ');
  const randomParagraphs: ParagraphProps = [];
  const maxLength =
    length === '아주 짧게'
      ? 16
      : length === '짧게'
      ? 40
      : length === '중간'
      ? 80
      : 120;

  for (let i = 0; i < count; i++) {
    let paragraph = '';
    while (paragraph.length < maxLength) {
      const randomIndex = Math.floor(Math.random() * lines.length);
      paragraph += lines[randomIndex] + ' ';
    }
    randomParagraphs.push(paragraph.trim());
  }

  return randomParagraphs;
};
```

### 3. 동작 확인 및 스타일링

정상적으로 동작되는지 확인하고 emotion/styled를 이용해 UI 스타일링을 했습니다.

![이미지](images/kr-lipsum.gif)

## 결과

- [kr-lipsum.netlify.app](https://kr-lipsum.netlify.app/)
- 한글 로렘 입숨이 필요한 분들이라면 사용해보시고 의견을 남겨주세요!

## 회고

- 개발자가 되고 싶었던 이유를 실현해볼 수 있었습니다.
- 디자이너와 개발자 사이에서 기획적인 부분을 잘 조절하며 진행한 것 같습니다.
- `for`함수와 `while`함수를 사용하면서 둘의 차이를 다시 한 번 공부할 수 있었습니다.
- 시간을 좀 더 쏟아부어서 짧은 기간에 완성했으면 하는데 그렇지 못한 것은 아쉬웠습니다.
